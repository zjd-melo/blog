---
title: 计算机网络传输层02
date: 2024-04-06 15:06:54
updated: 2024-04-06 15:06:54
categories: 计算机网络
tags: 网络
description: 计算机网络传输层 TCP 协议
---

## TCP 概述
- 点对点 一个发送方一个接收方
- 可靠的、按序的字节流
- 流水线机制 TCP拥塞控制和流量控制机制设置窗口尺寸
- 发送方/接收方缓存
- 全双工
  - 同一个连接中能够传输双向数据流
- 面向连接
  - 通信双方在发送数据前必须建立连接
  - 连接状态只在连接的两端中维护，在沿途节点中并不维护状态
  - TCP 连接包括两台主机上的缓存、连接状态变量、socket 等
- 流量控制机制

## 序列号和 ACK
### 序列号
- 序列号指的是 segment 中第一个字节的编号，而不是 segment 的编号
- 建立 TCP 连接时，双方随机选择序列号

### ACKs
- 希望接收到的下一个字节的序列号
- 累计确认：该序列号之前的所有字节均已被正确接收到

问题：接收方如何处理乱序到达的 segment？

TCP 规范中没有规定，由 TCP 的实现者做出决策。

## TCP 可靠数据传输概述
- TCP 在 IP 层提高的不可靠服务基础上实现可靠数据传输服务
- 流水线机制
- 累计确认
- TCP 使用单一重传定时器 （和 SR 不同）
- 触发重传的事件
  - 超时
  - 收到重复 ACK
- 渐进式
  - 暂不考虑重复 ACK
  - 暂不考虑流量控制
  - 暂不考虑拥塞控制

## TCP RTT 和超时
### 如何设置定时器的超时时间
1. 大于 RTT，但是 RTT 是变化的
2. 过短，不必要的重传
3. 过长，对段丢失时间反应慢

### 如何估计 RTT
#### SampleRTT
测量从段发出去到收到 ACK 的时间，忽略重传
#### SampleRTT 变化
测量多个 SampleRTT，求平均值，形成 RTT 的估计值 EstimatedRTT

指数加权移动平均典型值=0.125

`EstimatedRTT=(1-x)*EstimatedRTT + x*EstimatedRTT`

#### 定时器超时时间的设置
- EstimatedRTT + "安全边界"
- EstimatedRTT 变化大 --> 较大的边界

#### 测量 RTT 的变化值：SampleRTT 与 EstimatedRTT 的差值
`DevRtt = (1-x)*DevRtt + x*|SampleRtt - EstimatedRTT|` 一般 x = 0.25

#### 定时器超时时间设置
`TimeoutInterval = EstimatedRTT + 4*DevRTT`

## TCP 发送方事件
### 从应用层收到数据
- 创建 Segment
- 序列号是 Segment 第一个字节的编号
- 开启计时器
- 设置超时时间：TimeOutInterval
### 超时
- 重传引起超时的 Segment
- 重启定时器
### 收到 ACK
- 如果确认此前位确认的 Segment
  - 更新 SendBase
  - 如果窗口中还有未被确认的分组，重新启动定时器

### TCP 重传示例
![TCP重传](TCP重传.png)
![TCP累计确认](TCP累计确认.png)

## TCP 接收方
![接收方事件](接收方事件.png)

## 快速重传机制
1. TCP 的实现中，如果发生超时，超时时间间隔将重新设置，即将超时时间间隔加倍，导致其很大，重发
丢失的分组之前要等待很长时间。
2. 通过重复 ACK 检测分组丢失，Sender 会背靠背地发送多个分组，如果某个分组丢失，可能会引发多个重复 ACK。
3. 如果 Sender 收到对同一个数据的 3 个 ACK，则假定该数据之后的段已经丢失。

快速重传解决这些问题，即在定时器超时之前即进行重传。

为什么是 3 次？

## TCP 流量控制 速度匹配机制
![流量控制](流量控制.png)
接收方为 TCP 连接分配 buffer，上层应用可能处理 buffer 中数据的速度较慢。

flow control 发送方不会传输太多、太快以至于淹没接收方（buffer 溢出）

假定 TCP receiver 丢弃乱序的 segments。

`buffer 中的可用空间（space room）= RcvWindow = RcvBuffer - (LastByteRcvd - LastByteRead)`

- Receiver 通过在 segment 的头部字段将 RcvWindow 告诉 Sender
- Sender 限制自己已经发送的但还未收到 ACK 的数据不超过接收方的空闲 RcvWindow 尺寸
- Receiver 告诉 Sender RcvWindow=0，会出现什么情况？即使为0，发送方也会发送很小的段，以便收不到接收方的确认，从而导致死锁。

## TCP 连接管理
TCP sender 和 receiver 在传输数据前需要建立连接，初始化 TCP 变量，Seq、Buffer 和 流量控制信息。

### 三次握手
1. 客户端发送 TCP SYN 段 到服务器，指定 initial seq，不包含数据
2. 服务器接收 SYN，返回 SYNACK 段，服务器分配 buffer，指定服务器端 initial seq
3. 客户端接收 SYNACK，返回 ACK 段，此时可能会包含数据

![三次握手](三次握手.png)

客户端在收到服务器的确认后，可以不给服务器发送确认，达到攻击的目的。

### 四次挥手
1. 客户机像服务器发送 TCP FIN 控制 Segment
2. 服务器收到 FIN，回复 ACK，关闭连接，发送 FIN
3. 客户机收到 FIN，回复 ACK，进入等待，如果收到 FIN，会重新发送 ACK，确认服务器成功释放资源
4. 服务器收到 ACK，连接关闭

![四次挥手](四次挥手.png)